[[
title: Cheat sheet по openssl.
timestamp: 2015-05-06 15:14
author: sbog
Tags: cheatsheet, openssl
blurb: auto
]]

Я постоянно забываю, какие команды нужно вводить при генерации сертификата. Это
просто невозможно запомнить. Поэтому я написал небольшой cheat sheet на эту 
тему. Итак, начнем.

Если кто забыл, небольшое напоминание, что же, собственно, может нагенерить
openssl:

* Открытый ключ (у меня это будет *.pub)
* Закрытый ключ (*.key)
* Запрос на сертификат (открытый ключ + информация о владельце ключа) - *.csr
* Сертификат (открытый ключ + информация о владельце ключа, все это подписано
  закрытым ключом) - тут есть тонкости, описанные ниже - *.crt

Что такое открытый ключ? Это просто строка символов, которая будет использоваться
в роли ключа.

Что такое закрытый ключ? Это строка символов, имеющая такое свойство, что будучи
примененной к тексту, зашифрованному открытым ключом, раскроет оригинальный
текст. Стоит учесть, что обратный процесс точно так же работает.

Стоит отметить, что открытый и закрытый ключ образуют пару. Использоваться они могут,
соответственно, тоже только в паре.

Что такое запрос на сертификат? Это открытый ключ, к которому дописываются данные
о владельце ключа и все это миксуется в специфичный формат.

Что такое сертификат? Это подписанный кем-то запрос на сертификат (тот же самый
запрос на сертификат, к которому просто добавляется подпись). Подписан сертификат
может быть разными ключами. Существует два основных метода:

1. Так называемый самоподписанный сертификат. Это когда запрос на сертификат
подписывается ключом из той же пары, в которую входит открытый ключ в этом сертификате.
Т.е. генерируется пара из открытого и закрытого ключей, к открытому ключу дописывается
информация о владельце - получается запрос на сертификат - потом запрос подписывается
закрытым ключом.

2. Сертификат, подписанный с помощью CA (certificate authority, центр подписи). Это
выглядит так:
- какой-то дядя сделал себе самоподписанный сертификат
- вы генерируете себе открытый и закрытый ключи, затем генерируете на основе открытого
ключа запрос на сертификат
- вы даете дяде свой запрос. Он подписывает его СВОИМ закрытым ключом и отдает вам то,
что получилось. Вы в результате получаете сертификат, содержащий в себе ваш открытый ключ
и ваши данные о ключе, но все это подписано не вашим закрытым ключом, а чужим.


Нормальный человек может поинтересоваться, зачем нужны сертификаты, подписанные 
кем-то еще. Для ответа на этот вопрос давайте рассмотрим пример. Представьте
себе, что вы сгенерировали себе самоподписанный сертификат и с его помощью уже
общаетесь с другими людьми. Ничто не помешает кому-то еще сгенерировать себе
сертификат с другой парой ключей, но с вашими данными (это априори открытая
информация, она читается из сертификата и именно по ней и определяется, чей
это сертификат) и выдавать себя за вас. Чтобы этого не происходило, в современном
мире сделано следующее (на примере HTTP и браузеров):
- происходит все то, что описано в пункте 2, но при это дядя свой самоподписанный
сертификат отдал компании-разработчику браузеров и ваш браузер (любой
современный, например Chrome или Firefox) идет с ним в комплекте. Т.е. этот
сертификат в ваш браузер ПРЕДУСТАНОВЛЕН.
- когда вы хотите с кем-то безопасно пообщаться, вы лезете на сайт к тому, с
кем хотите общаться, скачиваете себе его сертификат. Этот сертификат подписан
закрытым ключом дяди, но чтобы проверить подпись, вам нужен только открытый ключ
этого дяди. А этот открытый ключ есть в дядином сертификате, который в ваш браузер,
напомню, предустановлен, т.е. он не может быть подменен по пути, потому что
вы его не скачиваете из сети, он у вас был с момента установки браузера.
- вы проверяете сертификат, подписанный дядиным ключом с помощью предустановленного
дядиного сертификата и убеждаетесь, что все ок. Теперь вы можете общаться.

В этой схеме подразумевается, что дядя - человек хороший и еще один сертификат
на ваше имя больше никому не выдаст. На этом держится вся индустрия по продаже
SSL сертификатов. В этой индустрии все гладко только в теории, но это вопрос уже
совершенно другого разговора, а у нас и так уже вступление подзатянулось.


Итак, как сгенерировать всю эту бодягу с помощью openssl:

1. Генерируем пару из открытого и закрытого ключей:

openssl genrsa -out secret.key 4096

Здесь:
- genrsa - подкоманда для openssl, которая говорит нам "парень, будем генерировать закрытый ключ"
- -out [название] - указывает нам выходное имя файла для ключей
- 4096 - количество бит в ключе


Здесь надо быть осторожным в определениях. Фактически, данная команда сгенерирует нам только
закрытый ключ. Но в файле будет содержаться информация о том, как сгенерировать открытый ключ
по закрытому. Поэтому, имея на руках только закрытый ключ, вы, фактически, имеете оба ключа.


2. Если сильно хочется, можно посмотреть, как выглядит открытый ключ, сгенерированный
из этого файла:

openssl rsa -in secret.key -pubout

Здесь:
- rsa - подкоманда для openssl, которая говорит "будем работать с rsa"
- -in [название] - указывает нам входное имя файла с закрытым ключом
- -pubout - сгенерирует открытый ключ из закрытого и выведет информацию на экран (ну
или что там у вас вместо него)


3. Просто посмотреть не очень полезно, лучше сохранить:

openssl rsa -in secret.key -pubout -out public.key

Здесь:
- rsa - подкоманда для openssl, которая говорит "будем работать с rsa"
- -out [название] - указывает нам выходное имя файла для открытого ключа

Теперь в public.key у нас лежит открытый ключ, а в private.key - закрытый.


4. Если мы хотим из имеющегося закрытого ключ сформировать вместо открытого ключа
запрос на сертификат, то мы можем сделать это так:

openssl req -key secret.key -new -out request.csr

Здесь:
- req - подкоманда, которая говорит нам, что мы будем генерировать запрос на сертификат
(вообще, создатели openssl занятные люди. Эта команда, как мы попозже увидим, умеет
делать много чего еще)
- -key [название] - указывает нам входное имя файла для закрытого ключа
- -new - говорит, что мы хотим сгенерировать именно запрос на сертификат
- -out [название] - указывает нам выходное имя файла для запроса на сертификат

Данная команда спросит у нас данные о владельце сертификата. Там немного полей, но если
ключи генерируются часто, то эти поля можно запихнуть в конфиг, а конфиг этот указать
как опцию. Чуть ниже будет пример.


5. Иногда мы можем захотеть сгенерировать сразу и закрытый ключ и запрос на сертификат:

openssl req -newkey rsa:2048 -nodes -keyout secret.key -out request.csr

Здесь:
- req - подкоманда, которая говорит нам, что мы будем генерировать запрос на сертификат
- -newkey [тип:количество бит] - указывает параметры секретного ключа
- -nodes - говорит, что мы не будем шифровать закрытый ключ секретной фразой (это иногда
делают, если хотят дополнительно защитить закрытый ключ паролем. Но не стоит этого делать, если
ключ будет использоваться в автоматической системе, типа http-сервера, иначе при каждом
перезапуске сервера вам придется вводить этот пароль)
- -keyout [название] - указывает нам выходное имя файла для закрытого ключа
- -out [название] - указывает нам выходное имя файла для запроса на сертификат



Уфф. Окей. Теперь настало время из нагенерированных данных создать сертификаты.

6. Как сгенерировать самоподписанный сертификат:

openssl req -newkey rsa:2048 -nodes -keyout secret.key -x509 -days 3650 -out certificate.crt

Здесь:
- req - подкоманда, которая говорит нам, что мы будем генерировать запрос на сертификат
- -newkey [тип:количество бит] - указывает параметры секретного ключа
- -nodes - говорит, что мы не будем шифровать закрытый ключ секретной фразой
- -keyout [название] - указывает нам выходное имя файла для закрытого ключа
- -x509 - указывает, что мы будем генерировать не запрос, а сразу сертификат
- -days [количество] - указывает количество дней, в течение которых сертификат будет валиден
- -out [название] - указывает нам выходное имя файла для сертификата

Эта команда все равно будет формировать временный .csr, просто вам его не покажут.


7. Стойте, у нас же был секретный ключ? Как сформировать самоподписанный сертификат
на основе уже имеющегося ключа:

openssl req -key secret.key -x509 -new -days 3650 -out certificate.crt

Здесь:
- req - подкоманда, которая говорит нам, что мы будем генерировать запрос на сертификат
- -key [название] - указывает нам входное имя файла для закрытого ключа
- -x509 - указывает, что мы будем генерировать не запрос, а сразу сертификат
- -new - говорит, что мы хотим сгенерировать именно запрос на сертификат. Это очень странное
сочетание вкупе с опцией 'x509' и в данном конкретном случае оно говорит "а давайте
мы будем генерить все-таки сертификат, но данные для временного запроса на сертификат
тоже спросим"
- -days [количество] - указывает количество дней, в течение которых сертификат будет валиден
- -out [название] - указывает нам выходное имя файла для сертификата


8. Окей, гугл. А что делать, если у нас есть не только закрытый ключ, но и запрос на сертификат
на его основе и нам нужен просто самоподписанный сертификат? Тогда мы можем сделать:

openssl x509 -signkey secret.key -in request.csr -req -days 3650 -out certificate.crt

Здесь:
- x509 - подкоманда для управления сертификатами. Я не знаю, кто сумел спроектировать все так,
что часть этого управления находится в команде 'req', честное слово
- -req здесь говорит, что у нас есть запрос на сертификат
- -signkey [название] - указывает нам входное имя файла для закрытого ключа
- -in [название] - указывает нам входное имя файла с запросом на сертификат
- -days [количество] - указывает количество дней, в течение которых сертификат будет валиден
- -out [название] - указывает нам выходное имя файла для сертификата


9. Мы близки к завершению. Осталось понять, как нам сделать свой CA и использовать его
для подписи сертификатов. Вообще, это довольно большая тема, а мы и так выбились за
рамки, поэтому вкратце:

- чтобы создать CA, достаточно просто создать самоподписанный сертификат.
- далее мы должны получить запрос на сертификат, который мы будем подписывать
- после этого мы можем подписать данный запрос:

openssl x509 -req -days 3650 -CA ca.crt -CAkey ca.key -set_serial 01 -extfile openssl-csr.cnf -extensions req_ext -in request.csr -out certificate.crt

Здесь:
- x509 - подкоманда для управления сертификатами
- -req здесь говорит, что у нас есть запрос на сертификат
- -days [количество] - указывает количество дней, в течение которых сертификат будет валиден
- -CA [название] - имя файла с CA сертификатом
- -CA [название] - имя файла с CA закрытым ключом
- -set_serial [номер] - серийный номер сертификата. Хранится на случай отзыва
- -extfile [название] - имя файла с конфигом, потому что часть опций можно указать только в нем
- -extensions [название] - название секции в файле с конфигом, из которой будут браться расширения
- -in [название] - указывает нам входное имя файла с запросом на сертификат
- -out [название] - указывает нам выходное имя файла для сертификата


Как я уже сказал, создание CA - это отдельная тема, которой я посвещу отдельную статью.
В остальном же мы покрыли большую часть основных команд openssl по созданию ключей
и сертификатов. На этом все, продолжение будет чуть позже.
